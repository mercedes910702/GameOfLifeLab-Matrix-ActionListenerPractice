import java.awt.*;

import javax.swing.*;
import javax.swing.Timer;

import java.awt.event.*;
import java.util.*; 

/*
 * Mercedes Moore
 * APCS A
 * Game Of Life Lab
 */

/*This class represents a simulation game introduced by British mathematician John Conway. 
The simulation is meant to represent organisms. Each cell of the grid is is either alive (which means an organism 
lives within that cell) or dead (meaning that no organism lives within that cell). The grid changes throughout a 
series of generations. From one generation to the next, cells with either die or be born. These processes are 
dependent on the total of alive neighbors nearby the cell. There are four rules within this simulation: (1) a
 neighbor of a given cell has a common side or corner with that cell. each cell inside the grid has 8 neighbors 
 (top left,top center, top right, left, right, bottom left, bottom center, and bottom right). (2) an alive cell 
 requires two or three alive neighbors to  continue living through the next generation. if an alive cell has less 
 than two alive neighbors, the cell dies. (3) a vacant cell can become alive in the next generation if it has exactly 
 three alive neighbors. (4) all births and deaths occur simultaneously, meaning that the change from one generation to
  the next in instantaneous. The class Grid serves as the "setting" for this simulation, and includes private variables*/
  
  
  //Grid class that sets up the Game of Life Grid object (not the graphics). This class represents the grid where the organism lives.
class Grid
{
	
	//Instance Variables
	private boolean[][] organismLocation; 

	//Utility Method
	/*
	 * pre: N/A
	 * post: returns a boolean value that dictates whether a spot is alive or dead depending on the number generated by the random object.
	 */
	private boolean fillGridSpot()
   {
		boolean organismOccupies = false; 
		
		Random gridRandom = new Random(); 
		if (gridRandom.nextDouble() < 0.3) 
      {
			organismOccupies = true; 
		}
		
		return organismOccupies; 
	}
	
	//Constructor
	/*
	 * pre: N/A
	 * post: creates a 60 by 60 matrix grid that is filled in each location by a boolean value provided by the utility method fillGridSpot(). this grid represents where the organisms live.
	 */
	
	public Grid() 
   {
		organismLocation = new boolean[60][60];
		
		
		for (int rPos = 0; rPos < organismLocation.length; rPos++) 
      {
			for (int cPos = 0; cPos < organismLocation.length; cPos++) 
         {
				organismLocation[rPos][cPos] = fillGridSpot(); 
			}
		}
	}
//Mutator method
/*
 * pre: a grid object must exist, a graphics object g must be passed in and initialized
 * post: depending on the boolean value in each position of the grid, this method will print a small 4 by 4 circle that represents an organism (if the cell is alive, if the cell is dead, the method prints nothing in that cell). this method, however, does not return anything. the graphics object g is merely created here so it can be used in a later method in the graphics class. 
 */
	public void displayGrid(Graphics g) 
   {
		for (int rPos = 0; rPos < organismLocation.length; rPos++) 
      {
			for (int cPos = 0; cPos < organismLocation.length; cPos++) 
         {
		
				if(organismLocation[rPos][cPos] == true) 
            {
					g.fillOval(cPos*5, rPos*5, 4, 4); 
				}
			}
	   }
   }

//Mutator method
	/*
	 * pre: a grid object must exist. the method changeSpot() must be initialized. 
	 * post: this method changes the boolean value of each location per each generation and stores it in a temporary grid that is then transposed to the original private grid object. 
	 */
	public void nextTurn() 
   {
		
		final boolean[][] tempGrid = new boolean[60][60]; 
		
		for (int rPos = 0; rPos < organismLocation.length; rPos++) 
      {
			for (int cPos = 0; cPos < organismLocation.length; cPos++) 
         {
				tempGrid[rPos][cPos] = changeSpot(rPos, cPos); 
			}
	   }
		organismLocation = tempGrid;
	
	}
	
//Utility Method 
	/*
	 * pre: a grid object must exist. the row position and column position parameters must be integers from the range [0, 60). 
	 * post: this method determines whether or not an organism will be alive or dead in one cell per generation depending on the number of neighbors. then, the method will store the new boolean value in each cell of the grid for the new generation. 
	 */
	public boolean changeSpot(int rowPos, int colPos) 
   {
	//Create a local variable to count alive cells 
		int aliveCounter = 0; 
		
		//Iterate over each spot to check its neighbors
		for (int rPos = rowPos-1; rPos <= rowPos+1; rPos++) 
      {
			for (int cPos = colPos-1; cPos <= colPos+1; cPos++) 
         {
				if (rPos >= 0 && rPos < 60 && cPos >= 0 && cPos < 60 && (rPos != rowPos || cPos != colPos) && organismLocation[rPos][cPos] == true) 
            {
					
					//Counts the alive neighbors 
					aliveCounter++; 
					
            }
         }
      }
		
	//First condition: counter is 2 or 3 and the checked cell is alive, cell stays alive
	if ((aliveCounter == 2 || aliveCounter == 3) && (organismLocation[rowPos][colPos]== true)) 
               {
						return true;
					}
					
	//Second condition: counter = 3 and the checked cell is dead, cell becomes alive
	else if (aliveCounter ==3 && organismLocation[rowPos][colPos] == false) 
               {
						return true; 
					}
					
			else 
               {
						return false; 
					}
				
			   }
	   }
//Graphics class that displays the grid created by the grid class. This window extends the JFrame class and creates a blank graphics window that displays the grid for each generation. 
class GraphicsWindow extends JComponent implements ActionListener {
	
	//Instance variables
	private int turns;
	private Timer time;
	private Grid myGrid;
	
	//Constructor
	/*
	 * pre:N/A
	 * post:creates a new Grid object and creates a graphics frame that displays the grid object from each generation.
	 */
	public GraphicsWindow() 
   {
		myGrid = new Grid();
		time = new Timer(2000, this);
		turns = 0;
		time.restart(); 
	}
	
	//Mutator method
	/*
	 * pre: a graphics object g must be initialized
	 * post:paints a graphics grid depending on the grid object g intialized earlier in the grid class. 
	 */
	public void paintComponent(Graphics g) 
   {
		super.paintComponent(g);
		Graphics2D g2 = (Graphics2D) g; 
		g2.setColor(Color.BLACK);

		myGrid.displayGrid(g2);
   }
	
	//Mutator method
	/*
	 * pre: an ActionEvent e must be initialized.
	 * post: this method paints and repaints the generations (noted by the number of terms) in the grid 
	 */
	public void actionPerformed(ActionEvent e) 
   {
		if (turns < 300)
		{
			turns = turns + 1;
			System.out.println("turn");
			myGrid.nextTurn();
			repaint();
		}
		
	}
}

//Driver Program
public class GameOfLifeLab 
{

	public static void main(String[] args) 
   {
		
		//Creates graphic frame
		JFrame frame = new JFrame();
		frame.setSize(240, 240);
		frame.setTitle("Game Of Life");
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setVisible(true);
		
		Component componentObject = new GraphicsWindow();
		frame.add(componentObject); 

	}
}
